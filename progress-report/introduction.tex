\section{Introduction}
In recent years processors have been running into limits in single-threaded processing speed \cite{cpu_clk_speed}. Overall performance has been increased by taking advantage of parallelism. This can be achieved using multiple cores to gain general parallelism or through hardware accelerators specifically designed to exploit the parallelism inherent in an algorithm. An example would be multiplying matrices. Many matrix operations involve computing many simpler calculations on the components of the matrix. These calculations are often independent and can be performed in parallel. A processor would compute these sequentially but a specific hardware implementation would be able to compute them in parallel.

An FPGA allows hardware to be developed and iterated on much faster than other options such as using an ASIC or logic ICs. They allow hardware to be designed with HDL code that is then constructed on the FPGA \cite{whatisanfpga}. For this reason, they will be used in this project to implement the accelerator. Some FPGA boards have a built-in processor but the board used in this project does not so that will also be constructed on the FPGA.

RISC-V is a good option for this processor as it is an open standard instruction set architecture \cite{risc} that can be implemented by anyone and has multiple options for FPGA implementations such as Rocket Chip \cite{rocketchip}. It is also used extensively in other products such as high-performance SiFive boards and the low-power Espressif's ESP32-C3 microcontroller. Because of this adoption, more libraries are available such as a port of Debian.

\newpage
\subsection{Objectives}

Develop a hardware accelerator for a RISC-V processor communicating over the AXI bus and compare it against a bare-metal software solution.

\begin{itemize}
	\item Generate a RISC-V core on an FPGA and run bare-metal code on it (Must).
	\item Design an IP block that connects to the RISC-V's AXI bus that can send and receive data (Must).
	\item Design an IP block that performs the hardware-accelerated functionality (Must).
	\item Develop a driver in bare-metal C code to use the accelerator (Must).
	\item Design and implement a test for the accelerator (Must).
	\item Implement the test using a software approach and compare results (Should).
	\item Implement a hardware accelerator using an alternative method of communication such as an APB bus and compare (Could)
	\item Run Linux on the processor and make the accelerator available for use (Won't)
\end{itemize}

\subsection{Related work}
\subsubsection{Implementation of a RISC-V Processor with Hardware Accelerator \cite{risc-v_hard_accel}}
This paper covers the development of a hardware matrix multiplier for a RISC-V processer. They used a ZedBoard which uses the same Artix-7 FPGA chip as the Nexys A7 100T that this project uses. They use PULPino \cite{pulpino}, a 32-bit single-core RISC-V microprocessor. This project does not support the Nexys A7 100T FPGA used in our project so vivado-risk-v \cite{vivado-risk-v} is used to generate a 64-bit RISC-V core using the Rocket Chip project \cite{rocketchip}. This takes more of the resources available to the FPGA but can be reduced to 32-bit if needed as we will not be running Linux. They used the APB bus to communicate between the accelerator and PULPino microprocessor due to its interface being simpler than the AXI bus. In our project, the AXI interface will be used as it recommended by the base project and provides the option for higher-performance transfers. When tested their accelerator reduced the number of clock cycles required from 603 to 134. This is a good improvement but due to the processor having a clock speed of 5 MHz, it is unable to compete with modern processors. They encountered many errors when trying to build C programs for the PULPino and required much trial and error. The process for compiling code for our project has proved much simpler.

\subsubsection{Matrix Multiplication Accelerator \citep{matrix_mult_accel}}
This paper also used an accelerator for matrix multiplication but with a DE1-SoC board using a built-in ARM Cortex-A9 HPS as the processer and a Cyclone V FPGA. They used parallel ports to communicate between the HPS and FPGA \cite{pio}. Two approaches were used based on the naive method. The first was to store the input matrices in two registers and use massive parallelization to set the values in the output register. This allowed values to be accessed with zero cycles of latency and in parallel but is very hard to scale. The other method used M10k memory blocks to store the inputs. These only have a single read and write port limiting the ability to exploit parallelism so they opted to improve performance by pipelining and increasing clock speeds. Their tests showed that the HPS performed better than their accelerator but performed significantly more consistently than the HPS. The accelerator and HPS ran at very different clock speeds, 100MHz and 925MHz. As the tests measured runtime in ms this would have heavily benefited the HPS. A clock cycle test as used in "Implementation of a RISC-V Processor with Hardware Accelerator" may have provided more comparable results.